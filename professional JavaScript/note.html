<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/276742; Windows/10.0.10586 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1271"/>
<h1>JavaScript高级编程笔记</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2014/2/17 14:09</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2016/3/14 10:54</i></td></tr>
</table>
</div>
<br/>

<div>
<span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><span style="font-size: 19px;"><font color="#41AD1C">Chapter 1 JavaScript简介</font></span></span><div>总结提要：</div><div>JavaScript主要由三个不同的部分组成：</div><div><b>ECMAScript</b>——由ECMA-262定义，提供核心语言功能</div><div><b>文档对象模型(DOM)</b>——提供访问和操作网页内容的方法和接口</div><div><b>浏览器对象模型(BOM)</b>——提供与浏览器交互的方法和接口</div><div><br/></div><div>JavaScript诞生于1995年，开始主要的目的是处理以前由服务器端语言(如perl)负责的一些输入验证操作。它是Netscape(网景公司)最初的杰作。但后来微软的IE浏览器加入JScript的JavaScript实现，出现两个标准的JavaScript。1997年，欧洲计算机制造商协会(ECMA)给出了ECMA-262，第一个JavaScript的标准。</div><div>但一个完整的JavaScript包括：核心(ECMAScript)，文档对象模型(DOM)，浏览器对象模型(BOM)</div><div><br/></div><div>ECMAScript</div><div>ECMAScript的组成部分:语法，类型，语句，关键字，保留字，操作符，对象</div><div>ECMAScript版本：截止到2009年位置，ECMAScript发布了5个版本，<b>第三版标志ECMAScript成为一门真正的编程语言</b>。(修改内容涉及：字符串处理，错误定义和数值输出；新增：正则表达式，新控制语句，try-catch异常处理)</div><div><b>ECMAScript支持Unicode标准</b></div><div><br/></div><div><b>文档对象模型(DOM)</b></div><div>针对XML但经过扩展用于HTML的应用程序编程接口(API)</div><div>通过DOM创建的文档树形图，借助DOM的API，开发人员可以轻松删除，添加，替代或修改任何节点</div><div>DOM的级别：</div><div>     <b>DOM1级</b>——DOM Core和DOM HTML</div><div>     <b>DOM2级</b>——新增DOM视图(DOM Views)，DOM事件(DOM Events)，DOM样式(DOM Style)，DOM遍历和范围(DOM Traversal and Range)</div><div>     <b>DOM3级</b>——新增加载和保存文档的方法(在DOM Load and Save 模块中定义)，验证文档的方法(DOM Validation模块中定义)，支持XML1.0规范</div><div>     传说中的DOM0级——IE4.0和Netscape Navigator 4.0最初支持的DHTML</div><div>DOM的其他标准：SVG(可伸缩矢量图) MathML(数字标记语言) SMIL(同步多媒体集成语言)</div><div><br/></div><div><b>浏览器对象模型(BOM)</b></div><div>2014-2-17 14:13</div><hr/><div><span style="font-size: 19px;"><font color="#41AD1C">Chapter 2 在HTML中使用JavaScript</font></span></div><div>总结提要：</div><div>在HTML页面中使用JavaScript要使用&lt;script&gt;&lt;/script&gt;标签。可以引入外部JavaScript文件或内嵌JavaScript代码</div><div>包含外部JavaScript文件时，用src包含相应文件的URL，文件可以来自任意域</div><div>&lt;script&gt;元素最后放在主要内容后面，即&lt;/body&gt;标签前面</div><div>所有不使用defer async属性的&lt;script&gt;元素都会按照它们在页面出现的先后顺序依次被解析</div><div>延迟脚本使用<b>defer=&quot;defer&quot;</b>属性，脚本在文档完全呈现之后再执行。延迟脚本是顺序执行的</div><div>异步脚本使用<b>async=&quot;async&quot;</b>属性，当前脚本不必等待其他脚本，也不必阻塞文档呈现。异步脚本不保证顺序执行</div><div><b>最好一个页面最多只包含一个延迟脚步或异步脚本</b></div><div>&lt;noscript&gt;指定不支持JavaScript脚本的浏览器中显示的替代内容</div><div><br/></div><div>&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;中德type不是必须的，如果没有指定这个属性，默认值为text/javascript</div><div>嵌入JavaScript代码中，不能包含&lt;/script&gt;代码，可以用&lt;\/script&gt;转义字符&quot;\&quot;来解决</div><div>JavaScript文件不必带.js扩展名，但通过动态脚本PHP等产生的JavaScript文件必须返回正确的<b>MIME类型(application/x-javascript)</b></div><div><b>通过src包含外部JavaScript脚本的&lt;script&gt;&lt;/script&gt;标签内再包含内嵌脚本，嵌入的代码会被忽略，只执行外部脚本</b></div><div><br/></div><div>在XHTML中使用JavaScript</div><div>&quot;&lt;&quot;符号会被XHTML当作为新标签的开始解析，所以要使用hack去兼容，如：</div><div>&lt;script&gt;</div><div><b>//&lt;![CDATA[</b></div><div>function compare(a,b){</div><div>     if(a&lt;b){</div><div>          alert(&quot;A is less than B&quot;);</div><div>     }else if(a&gt;b){</div><div>          alert(&quot;A is greater than B&quot;);</div><div>     }else{</div><div>          alert(&quot;A is equal to B&quot;);</div><div>     }</div><div>}</div><div><b>//]]&gt;</b></div><div>&lt;/script&gt;</div><div>开发时，尽可能使用外部js文件，这样有以下优点：可维护性，可缓存，适应未来</div><div><br/></div><div><b>文档模式(doctype)</b>：最初由IE引入<b>混杂模式(quirks mode)</b>和<b>标准模式(standards mode)</b>，<b>主要影响是CSS的加载上</b>，但有时也会影响JavaScript。而HTML使用的文档模式主要有以下 几种：</div><div>&lt;!-- HTML 4.01过渡型 --&gt;</div><div>&lt;!DOCTYPE html</div><div>PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; </div><div>&quot;http://www.w3.org/TR/html4/loose<code>.dtd</code>&quot;&gt;</div><div><br/></div><div>&lt;!-- HTML 4.01框架集型 --&gt;</div><div>&lt;!DOCTYPE html</div><div>PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; </div><div>&quot;http://www.w3.org/TR/html4/frameset<code>.dtd</code>&quot;&gt;</div><div><br/></div><div>&lt;!-- HTML 4.01严格型 --&gt;</div><div>&lt;!DOCTYPE html</div><div>PUBLIC &quot;-//W3C//DTD HTML 4.01 Strict//EN&quot; </div><div>&quot;http://www.w3.org/TR/html4/strict<code>.dtd</code>&quot;&gt;</div><div><br/></div><div>&lt;!-- XHTML 1.0 过渡型 --&gt;</div><div>&lt;!DOCTYPE html</div><div>PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; </div><div>&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional<code>.dtd</code>&quot;&gt;</div><div><br/></div><div>&lt;!-- XHTML 1.0 框架集型 --&gt;</div><div>&lt;!DOCTYPE html</div><div>PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; </div><div>&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset<code>.dtd</code>&quot;&gt;</div><div><br/></div><div>&lt;!-- XHTML 1.0 严格型 --&gt;</div><div>&lt;!DOCTYPE html</div><div>PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; </div><div>&quot;http://www.w3.org/TR/xhtml1/DTDxhtml1-/strict<code>.dtd</code>&quot;&gt;</div><div><br/></div><div>&lt;!-- HTML5 --&gt;</div><div>&lt;!DOCTYPE HTML&gt;</div><div>2014-2-17 16:09 /update 2016-3-10 9:48</div><hr/><div style="font-size: 19px;"><font color="#41AD1C">Chapter 3 基本概念</font></div><div>总结概要：</div><div>ECMAScript 5种基本数据类型：<b>Undefined Null Boolean Number String </b></div><div>ECMAScript复杂数据类型：<b>Object</b></div><div><b>严格模式：&quot;use strict&quot;;</b></div><div>基本运算符：算术运算符、布尔操作符、关系操作符、相等操作符及赋值操作符等</div><div>流控制语句：if语句、for语句、switch语句等</div><div>函数：ECMAScript函数任何时候可以返回任何值，<b>未指定返回值得函数返回一个特殊的undefined值</b>；ECMAScript没有函数签名的概念，<b>因为其函数参数是由arguments对象(类数组)的形式传递的</b>，所以，<b>ECMAScript函数也不能重载</b></div><div><br/></div><div><b>语法</b></div><div>ECMAScript中的一切(变量、函数名和操作符)都区分大小写(如类型判断符typeof不能使用typeOf)</div><div>ECMAScript标记符采用驼峰大小写格式</div><div><b>注释</b></div><div>// 单行注释</div><div><br/></div><div>/*</div><div>*多行注释</div><div>*</div><div>*/</div><div><br/></div><div><b>严格模式</b></div><div>ECMAScript 5引入严格模式(strict mode)，在代码的顶部添加：</div><div>&quot;use strict&quot;;</div><div>支持严格模式的浏览器包括：IE10+, Firefox 4+, Safari 5.1+, Opera 12+, Chrome</div><div><br/></div><div><b>关键字和保留字</b></div><div>关键字</div><div><table border="1" cellpadding="2" cellspacing="0" style="width:1369px;" width="100%"><tr><td style="width:29.364499634769903%;" valign="top">break</td><td style="width:23.082542001460922%;" valign="top">do</td><td style="width:28.56099342585829%;" valign="top">instanceof</td><td style="width:18.845872899926956%;" valign="top">typeof</td></tr><tr><td valign="top">case</td><td valign="top">else</td><td valign="top">new </td><td valign="top">var</td></tr><tr><td valign="top">catch</td><td valign="top">finally</td><td valign="top">return </td><td valign="top">void</td></tr><tr><td valign="top">continue</td><td valign="top">for</td><td valign="top">switch</td><td valign="top">while</td></tr><tr><td valign="top">debugger*</td><td valign="top">function</td><td valign="top">this</td><td valign="top">with</td></tr><tr><td valign="top">default</td><td valign="top">if</td><td valign="top">throw</td><td valign="top">delete</td></tr><tr><td valign="top">in</td><td valign="top">try</td><td valign="top"><br/></td><td valign="top"><br/></td></tr></table><div>保留字</div></div><table border="1" cellpadding="2" cellspacing="0" style="width:1855px;" width="100%"><tr><td style="width:21.88679245283019%;" valign="top">abstract</td><td style="width:26.037735849056602%;" valign="top">enum</td><td style="width:22.318059299191376%;" valign="top">int</td><td style="width:29.649595687331537%;" valign="top">short</td></tr><tr><td valign="top">boolean</td><td valign="top">export</td><td valign="top">interface</td><td valign="top">static</td></tr><tr><td valign="top">byte</td><td valign="top">extends</td><td valign="top">long</td><td valign="top">super</td></tr><tr><td valign="top">char</td><td valign="top">final</td><td valign="top">native</td><td valign="top">synchronized</td></tr><tr><td valign="top">class</td><td valign="top">float</td><td valign="top">package</td><td valign="top">throws</td></tr><tr><td valign="top">const</td><td valign="top">goto</td><td valign="top">private</td><td valign="top">transient</td></tr><tr><td valign="top">debugger</td><td valign="top">implements</td><td valign="top">protected</td><td valign="top">volatile</td></tr><tr><td valign="top">double</td><td valign="top">import</td><td valign="top">public<br/></td><td valign="top"><div><br/></div></td></tr></table><div><b>变量</b></div><div>var message; //未经初始化的变量会保存为一个特殊的值——undefined</div><div>函数中使用var定义的变量在函数退出后被销毁</div><div>省略var操作符，会创建一个全局变量，但不建议这样做</div><div><b>严格模式下，未经声明的变量赋值会抛出ReferenceError错误，也不能定义名为eval或arguments的变量</b></div><div><br/></div><div><b>数据类型</b></div><div><b>基本数据类型</b>：Undefined Null Boolean Number String</div><div><b>typeof操作符</b>：有时使用typeof操作符会返回令人疑惑的结果，如<b>typeof null将返回object</b>。解决类型检测请参考《Javascript程序员参考手册》</div><div><b>Undefined类型</b>：注意的一点事——对未初始化的变量执行typeof操作符会返回undefined，而对未声明的变量执行typeof也会返回undefined !</div><div><b>Null类型</b>：undefined值是派生自null的，如：</div><div>              <b> alert(null == undefined);  // true</b></div><div><b>Boolean类型</b>：true和false(严格区分大小写，并且true不一定等于1，false不一定等于0)，调用转型函数Boolean()可以将其他数据类型转换为Boolean类型</div><div><b>Number类型</b>：</div><div>     尽量使用十进制数值，在进行算术计算时，所有八进制和十六进制表示的数值将会转换成十进制数值</div><div>     <b>保存浮点数需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值</b></div><div>     数值范围：最大数<b>Number.MAX_VALUE</b> 最小数<b>Number.MIN_VALUE</b> 超过最小值或最大值的数值会被自动转换成——Infinity，可以用函数<b>isFinite()</b>判断，正负Infinity可以反问 <b>Number.NEGATIVE_INFINITY</b> 和 <b>Number.POSITIVE_INFINITY</b></div><div>     ECMAScript中使用IEEE754格式（二进制的格式）来表示整数和浮点数。即<b>能够精确表示1/2，1/4，但不能精确表示0.1</b></div><div>     在进行算术时，所有八进制和十六进制的数值最终被转换成十进制的数值</div><div><b>NaN类型</b>：这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(不会抛出错误)，<b>NaN不等于任何值，包括NaN本身。用isNaN()函数来判断是否数值</b></div><div><b>0除以0返回NaN，正数除以0返回Infinity，负数除以0返回-Infinity</b></div><div>数值转换函数：</div><div>     Number()——用于任何数据类型</div><div>     parseInt() parseFloat()——用于把字符串转换成数值</div><div>     parseInt(arg1,arg2)函数，第二个参数arg2表示转换的进制，10为十进制</div><div>String类型：<b>ECMAScript中的字符串是不可变的</b>，即字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值得字符串填充该变量</div><div>其他类型变量用toString()函数可以转换为字符串</div><div><b>Object类型</b></div><div>     ——constructor</div><div>     ——<b>hasOwnProperty</b>(propertyName)</div><div>     ——<b>isPrototypeOf</b>(object)</div><div>     ——<b>propertyIsEnumerable</b>(propertyName)</div><div>     ——toLocaleString()</div><div>     ——toString()</div><div>     ——valueOf()</div><div><b>基本操作符</b></div><div>一元操作符 </div><div>位操作符(按位非&quot;~&quot;  按位与&quot;&amp;&quot;  按位或&quot;|&quot;  按位异或&quot;^&quot;  左移&quot;&lt;&lt;&quot;  有符号右移&quot;&gt;&gt;&quot;  无符号右移&quot;&gt;&gt;&gt;&quot; ) 按位非操作的本质：操作数的负值减1</div><div>布尔操作符(逻辑非&quot;!&quot;  逻辑与&quot;&amp;&amp;&quot;  逻辑或&quot;||&quot;)</div><div>乘性操作符</div><div>加性操作符：加号还可以是两个字符串拼接</div><div>关系操作符</div><div>相等操作符(相等&quot;==&quot;  不相等&quot;!=&quot; 全等&quot;===&quot; 不全等&quot;!==&quot;)</div><div>条件操作符(variable = boolean_expression ? true_value : false_value;)</div><div>赋值操作符</div><div><br/></div><div><b>语句</b></div><div>if语句</div><div>do-while语句</div><div>while语句</div><div>for语句 </div><div>for-in语句 for (var property in expression) statement</div><div>label语句？// 不太明白</div><div>continue和break语句</div><div>with语句 with(expression) statement; 将代码的作用域设置到一个特定的对象中 // 不建议使用with语句</div><div>switch语句 比较值时使用的是全等操作符，因为不会发生类型转换(例如：字符串&quot;10&quot;不等于数值10)</div><div><br/></div><div><b>函数</b></div><div><b>函数的参数由arguments对象保存，类似数组，但不是Array的实例。</b></div><div><b>arguments的值永远与对应命名参数的值保持同步</b></div><div><b>没有传递值得命名参数将会自动被赋予undefined值</b></div><div><b>ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数</b></div><div><b>ECMAScript函数不能重载</b></div><div><br/></div><div>记录于2014-2-17 23:45</div><hr/><div style="font-size: 19px;"><font color="#41AD1C">chapter 4 变量、作用域和内存回收</font></div><div>总结概要：</div><div>JavaScript变量可以用来保存两种类型的值：<b>基本类型值</b>和<b>引用类型值</b></div><div>所有变量都存在于一个执行环境(作用域)中，这个执行环境决定了变量的声明周期以及哪一部分代码可以访问其中的变量</div><div>JavaScript是一门具有自动垃圾收集的编程语言，开发人员不必关心内存分配和回收问题</div><div><br/></div><div><b>ECMAScript变量类型</b></div><div><b>基本类型值</b>：Undefined、Null、Boolean、Number和String 被保存在<b>栈内存</b>中<br/><b>引用类型值</b>：Object 被保存在<b>堆内存</b>中<br/>
引用类型值复制：当从一个变量向另外一个变量复制引用值时，实际上是<b>复制一个指针副本</b>，两个变量(指针)指向存储在堆中的同一个对象。所以改变其中一个变量，就会影响另一个变量。</div><div>ECMAScript函数的所有参数都是按值传递的：<b>传递的参数会在函数内部创建一个arguments对象，函数执行完，arguments对象销毁</b>。</div><div>传递参数令人疑惑：<b>在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。但，如例2，但将这个局部变量指向新的Object，即不再指向这个地址，那么之后的所有修改不会影响外部的值。</b></div><div>区分两个例子：</div><div>eg:</div><div>function setName(obj){</div><div>     obj.name=&quot;mbl&quot;;</div><div>}</div><div>var person=new Object();</div><div>setName(person);</div><div>alert(person.name); // &quot;mbl&quot;</div><div><br/></div><div>eg:</div><div>function setName(obj){</div><div>     obj.name=&quot;mbl&quot;;</div><div>     obj=new Object();</div><div>     obj.name=&quot;Greg&quot;;</div><div>}</div><div>var person=new Object();</div><div>setName(person);</div><div>alert(person.name); // &quot;mbl&quot;</div><div><br/></div><div>检测类型：解决类型检测请参考《Javascript程序员参考手册》。确定一个值是哪种类型可以用typeof操作符，而确定是哪种引用类型可以使用instanceof操作符。</div><div><br/></div><div><b>执行环境及作用域</b></div><div>作用域链：当代码在一个环境中执行时，会创建变量对象的一个<b>作用域链(scope chain)</b>，保证对执行环境有权访问的所有变量和函数的有序访问。</div><div>标示符解析：沿着作用域链一级一级地搜索标记符的过程。<b>搜索过程从作用域；链的前端开始，然后逐级地向后回溯，直到找到标记符为止，找不到会导致错误。</b></div><div><b>内部环境可以通过作用域链访问所有的外部环境</b>，外部环境不能访问内部环境中的任何变量和函数。<br/><b>延长作用域</b>：通过try-catch语句的catch块和with语句 (不常用)<br/><b>JavaScript没有块机作用域</b>，即像if语句、for语句内声明的变量在语句结束后还可以被访问。</div><div><br/></div><div><b>垃圾收集</b></div><div>JavaScript具有自动垃圾收集机制，主要收集的方式有两种：<b>标记清除</b>(mark-and-sweep)和<b>引用计数</b></div><div><b>标记清除</b></div><div>垃圾回收器运行时给内存中的所有变量的某个标志位标记，然后去掉环境变量中的变量以及被环境变量引用的变量的标记，当执行完环境后，这些变量某个标志位被标记为另外的值，在垃圾收集器下一次运行内存清除时将这些变量的内存空间回收。</div><div><b>引用计数(reference counting)</b></div><div>跟踪记录每个值被引用的次数，当引用次数为0时，将其占用的内存空间回收。</div><div><b>引用计数会造成循环引用的问题。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。</b></div><div>eg:</div><div>function problem(){</div><div>     var objectA=new Object();</div><div>     var objectB=new Object();</div><div>     objectA.somOtherObject=objectB;</div><div>     objectB.anotherObject=objectA;          </div><div>}</div><div>eg:</div><div>var element=document.getElementById('some_element');<br/>
var myObject=new Object();<br/>
myObject.element=element;<br/>
element.someObject=myObject; //循环引用<br/><b>//在不使用时，手动断开原生Js对象与DOM元素之间的连接</b><br/>
myObject.element=null;</div><div>element.someObject=null;</div><div><br/></div><div>目前主流浏览器IE、Firefox、Opera、Chrome、Safari使用的都是标记清除式的垃圾收集策略。</div><div>但IE中有一部分对象并不是原生JavaScript对象。如BOM和DOM的对象是使用C++以COM(<b>Component Object Model, 组件对象模型</b>)对象的形式实现的。<b>COM对象的垃圾收集机制是引用计数策略。</b></div><div>IE9把BOM和DOM对象都转换成真正的JavaScript对象</div><div><br/></div><div>性能问题</div><div>垃圾收集器多长时间运行一次，这个时间应该是根据内存回收垃圾量的大小而动态改变的。在有的浏览器中可以触发垃圾收集过程，如<b>IE中可以调用window.CollectGarbage()、Opera 7及更高版本可以调用window.opera.collect()</b>，但不建议调用。</div><div><br/></div><div>将不再使用的变量设置为null来<b>解除引用(dereferencing)</b>是很好的编程习惯。这一做法对大多数全局变量和全局对象的属性有效。局部变量会在它们离开执行环境时自动被解除引用</div><div>update 2016-3-10</div><hr/><div><span style="font-size: 19px;"><font color="#41AD1C">chapter 5 引用类型</font></span></div><div><b>Object类型</b></div><div>通过对象字面量表示法创建对象时，如果在最后一个属性后面添加逗号，会在IE7及更早版本和Opera中导致错误。</div><div>利用字面量对象作为函数的传入参数是个不错的选择。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数</div><div>访问对象的属性，可以用<b>点表示法</b>，也可用<b>数组的方式</b>来访问。数组的方式好处在于能够传入变量动态访问。</div><div><br/></div><div>Array类型</div><div>创建：1. 使用Array构造函数（可以忽略new操作符）；2. 使用数组字面量表示法。</div><div>var values=[1,2,]; //不要这样创建数组，会创建一个2或3项的数组，在IE中可能创建3个项的数组，而在其他浏览器中会创建2个项的数组</div><div><b>原因是IE8及之前版本中的ECMAScript实现在字面量方面有bug</b></div><div><b>数组的length属性很有特点——它不是只读的</b>。即可以通过设置length属性来从数组的末尾移除项或向数组中添加新项。</div><div>var colors=['red','blue','green'];</div><div>colors[colors.length]='black'; //相当于colors.push('black');</div><div>检测数组的方法，参考《JavaScript程序员指南》。</div><div>ECMAScript中新增了<b>Array.isArray()</b>方法。支持的浏览器又IE9+, Firefox 4+, Safari 5+, Opera 10.5+和Chrome。</div><div><b>转换方法</b>，toString()：返回','相隔的字符串；valueOf()返回的还是数组；toLocaleString()：</div><div><b>join()方法</b>。 eg: colors.join(','); 如果不给方法传入任何值，或者给它传入undefined，则使用逗号为分隔符。但在IE7及更早版本中会错误地使用“undefined”作为分隔符</div><div><b>栈方法</b>：LIFO (Last-In-First-Out)，方法：push() 和 pop()</div><div><b>队列方法</b>：FIFO(First-In-First-Out)，方法：shift() 和 push()  unshift() 和 pop()</div><div><b>重排序方法</b>：reverse() 和 sort()</div><div>sort()方法可以传入函数，自定义排序类型</div><div><b>操作方法</b></div><div><b>concat()</b>：返回一个新数组；eg:</div><div>var colors=['red','green','blue'];</div><div>var colors2=colors.concat('yellow',['black','brown']);</div><div><b>slice()方法：截取数组，返回一个新数组，不会影响原数组</b></div><div><b>splice()</b></div><div>1. 删除，可以删除任何数量项。 splice(0,2) 删除数组中的前两项</div><div>2. 插入，三个参数：起始位置，0（要删除的项数），要插入的项。 splice(2, 0, 'red', 'green')，在位置2插入字符串“red”和“green”</div><div>3. 替换， splice(2, 1, 'red', 'green') 删除位置为2的项，再插入“red”和“green&quot;两项</div><div><b>位置方法 indexOf() 和 lastIndexOf()</b></div><div><b>迭代方法：</b></div><div>1. <b>every()</b> 给定一个函数，如果每个项都访问true，则返回true</div><div>2. <b>filter()</b> 给定一个函数，返回这个返回返回为true的项组成的数组</div><div>3. <b>forEach()</b> 给定一个函数，这个方法没有返回，只是对所有的项都执行这个函数</div><div>4. <b>map()</b> 给定一个函数，返回每次函数调用的结果组成的数组</div><div>5. <b>some()</b> 给定一个函数，任意一个项返回true，都返回true</div><div>归并方法：<b>reduce()</b>和<b>reduceRight()</b>，接受4个参数，前一个值，当前值，项的索引和数组对象。eg:</div><div>var values=[1,2,3,4,5];</div><div>var sum=values.reduce(function(prev,cur,index,array){</div><div>     return prev+cur;</div><div>});</div><div><br/></div><div><b>Date类型</b></div><div>var now=new Date();</div><div>ECMAScript提供 <b>Date.parse()</b>方法和<b>Date.UTC()</b>方法，返回一个日期对象。</div><div><b>Date.parse()方法接受一个字符串。 Date.UTC(年份，基于0的月份，月的哪一天，小时，分，秒，毫秒)</b></div><div>ECMAScript添加Date.now()方法获取毫秒数，而可以用var time=+new Date(); 将Date对象转换为毫秒数</div><div>继承方法：toString(), toLocaleString() ——不同浏览器返回格式不一样；Date类型的valueOf()返回日期的毫秒数</div><div>日期格式化的方法：</div><div>1. toDateString() 实现特定格式的星期几，月，日和年</div><div>2. toTimeString() 实现特定格式的时，分，秒和时区</div><div>3. toLocaleDateString() 实现特定地区格式的星期几，月，日和年</div><div>4. toLocaleTimeString() 实现特定格式的时，分，秒</div><div>5. toUTCString() 完整UTC日期</div><div>日期、时间组件方法 P103</div><div><br/></div><div><b>RegExp类型</b></div><div>var expression= / pattern / flag;</div><div>匹配模式支持下列3个标志</div><div><b>g: 表示全局(global)模式；i: 表示不区分大小写(case-insensitive)； m: 表示多行模式(multiline)</b></div><div>//匹配第一个'bat'或'cat'，不区分大小写<br/>
var pattern1=/[bc]at/i;<br/>
//与pattern1相同，只不过使用构造函数创建的</div><div>var pattern2=new RegExp(&quot;[bc]at&quot;,&quot;i&quot;);</div><div><b>字面量模式与等价的字符串模式： /\[bc\]at\/  &quot;\\[bc\\]at&quot;</b></div><div><b>在ECMAScript 3中，正则表达式字面量始终会共享一个RegExp实例，而使用构造函数创建的每一个实例都是一个新实例</b>。 P105的经典案例。</div><div>而在ECMAScript 5中明确规定，使用正则表达式字面量都必须像直接调用RegExp构造函数那样，每次都创建新的RegExp实例。</div><div>RegExp实例属性</div><div>global：布尔值，表示是否设置了g标志</div><div>ignoreCase：布尔值，表示是否设置了i标志</div><div>lastIndex: 整数，下次搜索起始位置</div><div>source：正则表达式的字符串表示。存储的是字面量模式中的值</div><div><b>RegExp实例方法</b></div><div><b>exec()</b></div><div><b>test()</b></div><div>RegExp构造函数属性</div><div><br/></div><div><b>Function类型</b></div><div>函数实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法（构造函数的使用）。由于函数式对象，因此<b>函数名实际上是一个指向函数的指针</b>。</div><div>创建函数： <b>1. 函数声明；2. 函数表达式； 3. Function构造函数（不建议） </b></div><div>eg: var sum=new Function('num1','num2','return num1+num2'); //不推荐</div><div><b>JavaScript中没有函数重载</b></div><div><b>函数声明创建函数和函数表达式创建函数的区别是，函数声明创建的函数，在代码执行前，解析器就已经通过一个名为函数提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中</b></div><div><b>而表达式创建的函数在没有创建前调用会抛出“unexpected identifier”意外标识符的错误。</b></div><div><b>作为值的函数</b>：因为ECMAScript中函数名本身是变量，所以函数也可以作为值来使用。不仅可以像参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</div><div>按照特定的key的value来排序。</div><div>function createComparisonFunction(propertyName){<br/>
    return function(object1,object2){<br/>
        var value1=object1[propertyName];<br/>
        var value2=object2[propertyName];<br/>
        return value2-value1;<br/>
    };<br/>
}<br/>
var data=[{name:'chunzhen',age:'24'},{name:'miko',age:'24'}];<br/>
data.sort(createComparisonFunction('name'));</div><div>data.sort(createComparisonFunction('age'));</div><div><b>函数内部属性：arguments和this</b></div><div><b>arguments.callee，该属性是一个指针，指向拥有这个arguments对象的函数</b></div><div>利用arguments.callee消除函数执行与函数名之间的耦合关系。如下面阶乘函数：</div><div>function factorial(num){</div><div>    if(num&lt;=1){</div><div>        return 1;</div><div>    }else{</div><div>        return num*arguments.callee(num-1);</div><div>    }</div><div>}</div><div><b>当函数在严格模式下，访问arguments.callee会导致错误。</b></div><div><b>函数的对象和方法：</b></div><div>函数包含两个属性： 1. <b>length</b>: 表示希望接受命名参数的个数，也就是形参的个数；2. <b>prototype</b> 此属性不可枚举</div><div><b>每个函数都包含非继承而来的方法：apply() 和call()</b></div><div><b>apply()</b>: <b>第一个参数是运行函数的作用域；第二个参数是参数数组</b>。 而call() 方法第2-n个参数是参数列表。</div><div>apply()和call()的最强大之处在于，它能够扩充函数赖以运行的作用域</div><div>使用call()和apply()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系</div><div><b>ECMAScript 5还定义了 bind()方法</b>。 eg: syaColor.bind(o);</div><div><br/></div><div><b>基本包装类型</b> <b>Boolean, Number, String</b></div><div>引用类型与基本包装类型的主要区别就是<b>对象的生命周期</b>。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。<b>这意味我们不能在运行中为基本类型添加属性和方法</b>：</div><div>eg:</div><div>var s1=&quot;some text&quot;;</div><div>s1.color=&quot;red&quot;;</div><div>alert(s1.color); //undefined</div><div><b>Boolean类型</b></div><div>通过var booleanObject=new Boolean(false); 创建的为一个引用对象</div><div>即  booleanObject &amp;&amp; true; //返回true</div><div>而var booleanValue=false; booleanValue &amp;&amp; true; //返回false</div><div><b>基本类型与引用类型的布尔值还有两个不同</b>：1. <b>typeof操作符对基本类型返回“boolean”，而对引用类型返回“object”</b>；2. <b>由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false</b></div><div><b>Number类型</b></div><div><b>toFiexed()</b>方法，指定有效位数；<b>toExponential()</b>指数表示法；<b>toPrecision()</b>保留小数位数</div><div>同样地，Number对象是Number类型的实例，而基本类型的数值则不是</div><div><b>String类型</b></div><div>字符方法：<b>charAt()</b> 和 <b>charCodeAt()</b></div><div>字符串操作方法：<b>concat()</b> 与 加号一致；<b>slice()，substr()，substring()</b></div><div><b>在传递负参数时，slice()方法会将传入的负数与字符串长度相加；substr()方法将负的第一个参数加上字符串长度，而将第二个参数转换为0；substring()方法会将所有负值参数转换为0。</b></div><div>字符串位置方法：indexOf() ， lastIndexOf()</div><div>字符串大小写转换方法：toLowerCase()，toLocaleLowerCase()，toUpperCase()，toLocaleUpperCase()</div><div>字符串的模式匹配方法：<b>match() 与 RegExp的exec()一致</b>； <b>search()</b>； replace() ；split()</div><div>localeCompare方法，fromCharCode()方法</div><div><br/></div><div><b>单体内置对象</b></div><div><b>Global对象</b></div><div>对URI进行编码的方法：<b>encodeURI(), encodeURIComponent()</b>；解码方法：<b>decodeURI(), decodeURIComponent()</b></div><div><b>Math对象</b></div><div>max(), min(), ceil(), floor(), round(), random()</div><div><br/></div><div><span style="font-size: 19px;"><font color="#41AD1C">chapter 6 面向对象的程序设计</font></span></div><div>理解对象</div><div>创建对象的最简单方式是<b>创建一个Object实例</b>，另外一种方式是<b>对象字面量</b>。</div><div>ECMAScript中有两种属性：数据属性和访问器属性</div><div><b>数据属性</b>：[[Configurable]]、[[Enumerable]]、[[Writable]]、[[Value]] ECMAScript 5使用<b>Object.defineProperty()</b>方法修改属性的默认特性</div><div>可以多次调用Object.defineProperty()方法修改同一属性，但在把configurable特性设置为false后就有限制了</div><div><b>访问器属性</b>：[[Configurable]]、[[Enumerable]]、[[Get]]、[[Set]] 访问器属性不能直接定义，必须使用<b>Object.defineProperty()</b>定义</div><div>使用ECMAScript 5的<b>Object.GetOwnPropertyDescriptor()</b>方法，可以取得给定属性的描述符</div><div>创建对象</div><div><b>工厂模式 （不能识别对象）</b></div><div><b>构造函数模式</b></div><div>1. 没有显式地创建对象；2. 直接将属性和方法赋给this对象；3. 没有return语句。</div><div>按照惯例，构造函数始终以大小字母开头，而非构造函数则应该以一个小写字母开头</div><div>构造函数的主要问题是每个方法都要在每个实例上重新创建一遍</div><div><b>原型模式</b> 最重要记住：<b>原型里的所有属性和方法都是共享的</b></div><div><b>每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象。这个对象的用途是包含由特定类型的所有实例共享的属性和方法。</b></div><div>可以通过<b>isPrototypeOf()</b>方法和<b>Object.getPrototype()</b>方法来确定一个对象的原型</div><div>通过对象实例可以访问在原型中的值，但却不能通过对象实例重写原型中的值。在实例中创建与原型中相同的属性，则会屏蔽原型中的那个属性。可以通过<b>delete操作符</b>完全删除实例中的实例属性，从而可以重新访问原型中的属性</div><div>使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中</div><div>使用in操作符，通过访问对象给定的属性时返回true，无论该属性存在于实例中还是原型中</div><div><b>function hasPrototypeProperty(){</b></div><div><b>     return !object.hasOwnProperty(name) &amp;&amp; (name in object);</b></div><div><b>}</b></div><div>为prototype添加每一个方法都要敲一篇prototype，更常用的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象</div><div><b>原型的动态性</b></div><div>由于在原型中查找值得过程是一次搜索，因此对原型对象所做的任何修改都能够立即从实例上反映出来。因为实例与原型之间是通过指针来连接的。而当我们用字面量重写整个原型的时候，也就是断掉了指针的连接，就会覆盖掉原来的方法。</div><div><b>原型对象的问题</b>：所有的实例在默认情况下都取相同的属性值，是由其共享的本性所导致的。</div><div><b>组合使用构造函数模式和原型模式</b></div><div><b>构造函数定义属性，原型定义方法！</b></div><div>这种混合模式被广泛使用！</div><div><b>动态原型模型</b>：也就是判断当前的对象是否有某个方法，如果没有，则在原型对象中创建那个方法。</div><div><b>寄生构造函数模式</b> （与工厂模式一样，只是用new的方式来创建对象）</div><div>稳妥的构造函数模式：只有对应的方法能够访问到相应的属性，其他方法不能直接方法属性。避免数据被修改</div><div><br/></div><div><b>继承</b></div><div>ECMAScript主要靠原型链来继承，基本思想是<b>利用原型让一个引用类型继承另一个引用类型的属性和方法</b></div><div>function SuperType(){<br/>
     this.property=true;<br/>
}<br/>
SuperType.prototype.getSuperValue=function(){<br/>
     return this.property;<br/>
};<br/>
function SubType(){<br/>
     this.subproperty=false;<br/>
}<br/>
//继承了SuperType<br/>
SubType.prototype=new SuperType();<br/><br/>
SubType.property.getSubValue=function(){<br/>
     return this.subproperty;<br/>
};<br/><br/>
var instance=new SubType();</div><div>alert(instance.getSuperValue());     //true</div><div><br/></div><div>继承是通过创建SubType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以新类型的实例</div><div>给原型添加方法的代码一定要放在替换原型的语句之后</div><div>在通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做会重写原型链。</div><div><b>原型链的问题：1. 原型属性被所有实例共享；2. 创建子类型的实例时，不能向超类型的构造函数中传递参数</b></div><div><b>组合继承：思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</b></div><div>function SuperType(name){<br/>
     this.name=name;<br/>
     this.colors=['red','blue','green'];<br/>
}<br/>
SuperType.prototype.sayName=function(){<br/>
     alert(this.name);<br/>
};<br/>
function SubType(name,age){<br/>
     SuperType.call(this,name); //第二次调用SuperType()<br/>
     this.age=age;<br/>
}<br/>
SubType.prototype=new SuperType(); //第一次调用SuperType()<br/>
SubType.prototype.constructor=SubType;<br/>
SubType.prototype.sayAge=function(){<br/>
     alert(this.age);</div><div>};</div><div><br/></div><div><b>寄生组合式继承 最强大 只调用一次超类的构造函数</b></div><div>function object(o){<br/>
     function F(){}<br/>
     F.prototype=o;<br/>
     return new F();<br/>
}<br/>
function inheritPrototype(subType,superType){<br/>
     var prototype=object(superType.prototype);<br/>
     prototype.constructor=subType;<br/>
     subType.prototype=prototype;<br/>
}<br/>
function SuperType(name){<br/>
     this.name=name;<br/>
     this.colors=['red','blue','green'];<br/>
}<br/>
SuperType.prototype.sayName=function(){<br/>
     alert(this.name);<br/>
};<br/>
function SubType(name,age){<br/>
     SuperType.call(this,name);<br/>
     this.age=age;<br/>
}<br/>
inheritPrototype(SubType,SuperType());<br/>
SubType.prototype.sayAge=function(){<br/>
     alert(this.age);</div><div>};</div><div><br/></div><div><b>闭包：指有权访问另外一个函数作用域中的变量的函数</b></div><div>在全局函数中，this等于windows，匿名函数的执行环境具有全局性，因此其this对象通常返回window。需要在匿名函数中使用上一层this对象，对其保存var that=this;根据稳妥</div><div>循环引用将会使内存泄露</div><div><br/></div><div>模仿块级作用域</div><div><b>(function(){</b></div><div><b>     //这里是块级作用域</b></div><div><b>})(); </b></div><div>2016-3-4</div><div><br/></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 19px;">Chapter 8 BOM</span></span></div><div><b>window对象</b></div><div>window对象既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象</div><div><b>定义全局变量与在window对象上直接定义属性还有一点差别</b>：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。因为var添加的window属性的[[configurable]]为false</div><div>var age=29;<br/>
window.color='red';<br/>
//在IE&lt;9时抛出错误，在其他浏览器中返回false<br/>
delete window.age;<br/>
//在IE&lt;9时抛出错误，在其他浏览器中返回true<br/>
delete window.color;<br/>
alert(window.age); //29</div><div>alert(window.color); //undefined</div><div><b>同时，尝试访问未声明的变量会抛出错误，但通过查询window对象，不存在会返回undefined，不会抛出错误</b></div><div><br/></div><div>窗口关系与框架：1. <b>top对象</b>始终指向最高层的框架，即浏览器窗口；2. 每个window对象有<b>parent属性</b>，指向当前框架的直接上层框架；3. <b>self对象</b>，始终指向window</div><div><b>窗口位置</b></div><div><b>var leftPos=(typeof window.screenLeft=='number')? window.screenLeft : window.screenX;</b></div><div><b>var topPos=(typeof window.screenTop=='number')? window.screenTop:window.screenY;</b></div><div>窗口大小：很难确定浏览器窗口本身的大小，但却可以获得页面视口的大小。</div><div>一些方法：window.moveTo(x,y); window.moveBy(); window.resizeTo(x,y); window.resizeBy(x,y);</div><div>var pageWidth=window.<b>innerWidth</b>;<br/>
var pageHeight=window.<b>innerHeight</b>;<br/>
if(typeof pageWidth!='number'){</div><div>     if(document.compatMode=='<b>CSS1Compat</b>'){</div><div>          pageWidth=<b>document.documentElement.clientWidth</b>; //标准模式</div><div>          pageHeight=document.documentElement.clientHeight;</div><div>     }else{</div><div>          pageWidth=<b>document.body.clientWidth</b>; //混杂模式</div><div>          pageHeight=document.body.clientHeight;<br/>
     }</div><div>}</div><div><b>导航和打开窗口</b></div><div><b>window.open()</b> 方法接受4个参数：<b>1. 加载的URL；2. 窗口目标；3. 一个特性字符串；4. 一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值</b></div><div>第二个参数可以设置为一个frame的名称，也可以设置为：<b>_self, _parent,_top,_blank</b></div><div>新建窗口有一个<b>opener属性</b>，其中保存着打开它的原始窗口对象。而将window.opner=null;后，就是告诉新创建的标签页不需要与打开它的标签页通信</div><div>弹出窗口屏蔽程序，1. 可能是浏览器内置程序屏蔽，则调用window.open()后很可能返回null。而是浏览器扩展或其他程序阻止弹出窗口，则会抛出错误，要把代码放在try-catch块中</div><div><br/></div><div><b>间歇调用setInterval()</b> 和 <b>超时调用 setTimeout()</b></div><div>调用函数后会返回一个数值ID，调用 <b>clearTimeout()</b>和<b>clearInterval()</b>可以取消定时</div><div>一般认为，使用超时调用来模拟间歇调用时一种最佳模式，因为后一个间歇调用可能会在前一个间歇调用结束之前调用</div><div><br/></div><div>系统对话框 <b>alert(), confirm(), prompt()</b></div><div>window.print(); //显示“打印”对话框</div><div><b>window.find()</b>; //显示“查找对话框”</div><div><br/></div><div><b>location对象</b></div><div><b>location对象既是window对象的属性，也是document属性</b>。即window.location和document.location引用同一个对象</div><div>location的属性</div><ul><li><b>hash</b>: '#contents'</li><li><b>host</b>: 'www.mbl.com:80'</li><li><b>hostname</b>:'www.mbl.com'</li><li><b>href</b>:'http://www.mbl.com'</li><li><b>pathname</b>:'/abc/'</li><li><b>port</b>:'80'</li><li><b>protocol</b>:'http:'</li><li><b>search</b>:'?q=javascript'</li></ul><div><b>查询字符串参数</b></div><div>function <b>getQueryStringArgs()</b>{<br/>
     //取得字符串并去掉问号<br/>
     var qs=(location.search.length&gt;0)?location.search.substring(1):&quot;&quot;,<br/>
          args={},<br/>
          items=qs.length?qs.split('&amp;'):[],<br/>
          item=null,<br/>
          name=null,<br/>
          value=null,<br/>
          i=0,<br/>
          len=items.length;<br/>
          //逐个项添加到args对象<br/>
          for(i=0;i&lt;len;i++){<br/>
               item=item[i].split('=');<br/>
               name=decodeURIComponent(item[0]);<br/>
               value=decodeURIComponent(item[1]);<br/>
               if(name.length){<br/>
                    args[name]=value;<br/>
               }<br/>
          }<br/>
          return args;</div><div>}</div><div><br/></div><div>位置操作<b>location.assign()</b>方法，与调用location.href='另一个URL'相同</div><div><b>replace()</b>方法打开一个新页面，并不会再历史记录中生成新纪录</div><div><b>reload()</b>方法重新加载页面</div><div><br/></div><div><b>navigator对象</b></div><div>检测插件 IE和其他浏览器要使用不同的检测方法</div><div><br/></div><div><b>screen对象， history对象</b>（history.go(), history.back(), history.forward()）</div><div><br/></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 19px;">Chapter 10 DOM</span></span></div><div><b>节点层次</b></div><div>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。HTML元素通过元素节点表示；特性通过特性节点标签；文档类型通过文档类型表示；而注释通过注释节点表示。共有12种类型节点。</div><div><br/></div><div>Node类型</div><div>JavaScript所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。</div><div>每个节点都有一个NodeType属性，表明节点类型。</div><div><b>Node.ELEMENT_NODE(1);</b></div><div><b>Node.ATTRIBUTE_NODE(2);</b></div><div><b>Node.TEXT_NODE(3);</b></div><div><b>Node.CDATA_SECTION_NODE(4);</b></div><div>Node.ENTITY_REFERENCE_NODE(5);</div><div>Node.ENTITY_NODE(6);</div><div>Node.PROCESSING_INSTRUCTION_NODE(7);</div><div>Node.COMMENT_NODE(8);</div><div><b>Node.DOCUMENT_NODE(9);</b></div><div>Node.DOCUMENT_TYPE_NODE(10);</div><div>Node.DOCUMENT_FRAGMENT_NODE(11);</div><div>Node.NOTATION_NODE(12);</div><div><br/></div><div>这些数值常量在IE中无法访问，所以还是直接与数字值比较。</div><div>1. <b>nodeName和nodeValue属性</b></div><div><b>节点关系</b></div><div><b>DOM结构的变化能够自动反映在NodeList对象中，所以NodeList是有生命、有呼吸的对象</b>。可以通过方括号或item()还访问节点。</div><div><b>像前面一样，对arguments对象使用Array.prototype.slice()方法可以将其转换为数组，也可以适用于NodeList对象。</b></div><div><b>var arrayOfNodes=Array.prototype.slice.call(someNode.childNodes,0);</b></div><div>而在IE&lt;=8版本中无效，因为IE8中的NodeList对象实现为一个COM对象。在IE中要手动枚举。</div><div>使用<b>previousSibling</b>和<b>nextSibling</b>属性可以访问兄弟节点。使用父节点的<b>firstChild</b>和<b>lastChild</b>属性可以访问第1个和最后一个节点</div><div>操作节点：<b>appendChild()，insertBefore()，replaceChild()，removeChild()</b>。</div><div>其他方法：<b>cloneNode()</b>——一个boolean参数，设置为true则为深复制，false为浅复制</div><div>DOM树看成一系列指针连接起来的，但任何DOM节点不能同时出现在一个文档中的多个位置</div><div><br/></div><div><b>Document类型 nodeType:9</b></div><div><b>document.documentElement对应html元素；document.body对应&lt;body&gt;元素</b></div><div>文档信息：</div><div><b>通过修改document.title属性可以设置文档标题；</b></div><div>//取得文档标题<br/>
var originalTitle=document.title;<br/>
//设置文档标题</div><div>document.title='New page title';</div><div>document.domain </div><div><b>可以设置域。但浏览器对domain属性有一个限制，如果域名一开始是“松散的”(loost)，那么不能将它再设置为“紧绷的”(tight)。也就是，本来是全域名，不能再设置为一个子域名。</b></div><div>查找元素：<b>getElementById()</b>，<b>getElementsByTagName()</b>。</div><div>如果页面中多个元素的ID相同，getElementById()只返回文档中第一个出现的元素</div><div>特殊集合</div><div><b>document.anchors</b> 所有带有name特性的&lt;a&gt;元素</div><div><b>document.applets</b> 所有&lt;applet&gt;元素</div><div><b>document.forms</b> 所有&lt;form&gt;元素</div><div><b>document.images</b> 所有&lt;img&gt;元素</div><div><b>document.links</b> 所有带有href特性的&lt;a&gt;元素</div><div>文档写入：write(), writeln(), open(), close(), <b>在加载完的文档调用这些方法，将会重写整个页面</b></div><div><br/></div><div><b>Element类型 nodeType 1</b></div><div>HTML元素： 属性：<b>id， title，lang，dir(ltr, left-to-right; rtl )，className</b></div><div>取得属性：<b>getAttribute(), setAttribute(), removeAttribute()</b></div><div>创建元素：<b>document.createElement()</b></div><div>元素的子节点 <b>childNode属性</b></div><div><br/></div><div><b>Text类型 NodeType 3 NodeName:'#text'</b></div><div>操作文本的方法：<b>appendData</b>(text)， deleteData(offset, count)，insertData(offset, text)，replaceData(offset, count, text)，splitText(offset)，substringData(offset, count)</div><div>创建文本节点 <b>document.createTextNode()</b></div><div>如果两个文本节点是相邻的同胞，那么两个节点的文本会连起来显示，中间不会有空格</div><div><br/></div><div><b>Comment类型 nodeType 8</b></div><div><br/></div><div><b>CDATASection类型 nodeType 4</b></div><div><br/></div><div><b>DocumentType类型 nodeType 10</b></div><div><br/></div><div><b>DocumentFragment类型 nodeType 11</b></div><div><br/></div><div><b>Attr类型 nodeType 2</b></div><div><br/></div><div>DOM操作技术</div><div>动态创建脚本</div><div>function <b>loadScript(url)</b>{<br/>
     var script=document.createElement(&quot;script&quot;);<br/>
     script.type=&quot;text/javascript&quot;;<br/>
     script.src=url;<br/>
     document.body.appendChild(script);<br/>
}<br/>
function <b>loadScriptString(code)</b>{<br/>
     var script=document.createElement('script');<br/>
     script.type='text/javascript';<br/>
     try{<br/>
          <b>script.append(document.createTextNode(code));</b><br/>
     }catch(ex){<br/>
          <b>script.text=code;</b><br/>
     }<br/>
     document.body.appendChild(script);</div><div>}</div><div>动态样式</div><div>function <b>loadStyles(url)</b>{<br/>
     var link=document.createElement('link');<br/>
     link.rel='stylesheet';<br/>
     link.type='text/css';<br/>
     link.href=url;<br/>
     var head=document.getElementsByTagName('head')[0];<br/>
     head.append(link);<br/>
}<br/>
function <b>loadStyleString(css)</b>{<br/>
     var style=document.createElement('style');<br/>
     style.type='text/css';<br/>
     try{<br/>
          <b>style.appendChild(document.createTextNode(css));</b><br/>
     }catch (ex){<br/>
          <b>style.stylesheet.cssText=css;</b><br/>
     }<br/>
     var head=document.getElementsByTagName('head')[0];<br/>
     head.append(style);</div><div>}</div><div>操作表格</div><div><br/></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 19px;">chapter 13 事件</span></span></div><div><b>事件流</b></div><div>历史：<b>IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流</b></div><div><b>事件冒泡（event bubbling）</b></div><div>即事件开始由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）</div><div><b>事件捕获（event capturing）</b></div><div>DOM事件流</div><div>“DOM2级事件”规定事件流包括三个阶段：<b>事件捕获阶段</b>、<b>处于目标阶段</b>和<b>事件冒泡阶段</b>。</div><div><br/></div><div><b>DOM0级事件处理程序</b></div><div>var btn=document.getElementById('myBtn');</div><div>btn.onclick=function(){</div><div>     alert(this.id); //myBtn</div><div>};</div><div><b>通过这种方式添加的事件处理程序会在事件流的冒泡阶段被处理</b></div><div><br/></div><div><b>DOM2级事件处理程序</b></div><div>两个方法：<b>addEventListener()</b> 和 <b>removeEventListener()</b></div><div>接受3个参数：1. 要处理的事件名；2. 作为事件处理程序的函数；3. 布尔值，true，表示在捕获阶段调用事件处理程序；false，在冒泡阶段调用事件处理程序。</div><div>如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。</div><div>btn.addEventListener('click', handler, false);</div><div><br/></div><div><b>IE事件处理程序</b></div><div>两个方法：<b>attachEvent()</b> 和 <b>detachEvent()</b></div><div>接受2个参数：1. 事件处理程序名称和事件处理程序函数</div><div><b>由于IE8及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。</b></div><div>btn.attachEvent('onclick',handler); //注意！这里的事件名称为'onclick'</div><div><br/></div><div><b>在使用DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行；而在使用attachEvent()方法时，事件处理程序会在全局作用域中运行，因此this等于windows。</b></div><div>为一个元素添加多个相同的处理程序，这些事件不是以添加它们的顺序执行，而是<b>以相反的顺序被触发</b>。</div><div>使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。与DOM方法一样，这意味着添加的匿名函数将不能移除事件。</div><div><br/></div><div>跨浏览器的事件处理函数</div><div><b>先判断addEventListener-&gt;再判断attachEvent-&gt;最后用DOM0的方式添加</b></div><div><br/></div><div><b>DOM中的事件对象</b></div><div>btn.addEventListener('click', function(event){</div><div>     alert(event.type); //&quot;click&quot;</div><div>});</div><div>变量event中保存着event对象</div><div>属性（只读）：bubbles, cancelable, currentTarget, defaultPrevented, detail, eventPhase(事件处理阶段，1捕获，2“处于目标”，3冒泡)，target，trusted, type, view</div><div>方法：<b>preventDefault()</b>, stopImmediatePropagation(), <b>stopPropagation()</b></div><div><b>事件处理内部，对象this始终等于currentTarget值</b></div><div>要阻止特定时间的默认行为，可以使用preventDefault()方法</div><div><br/></div><div><b>IE中的事件对象</b></div><div><b>event对象作为window对象的一个属性存在</b></div><div>btn.onclick=function(){</div><div>     var event=window.event;</div><div>     alert(event.type); //&quot;click&quot;</div><div>};</div><div>属性</div><div><b>cancalBubble</b>: <b>与DOM中的stopPropagation()方法相同</b>。将window.event.cancalBubble=true; 可以取消事件冒泡</div><div><b>returnValue</b>：<b>与DOM中的preventDefault()方法相同</b>。将window.event.returnValue=false; 可以取消事件默认行为</div><div>srcElement：与DOM中的target相同</div><div>type：触发事件类型</div><div><br/></div><div>跨浏览器事件对象</div><div><br/></div><div><b>事件类型</b></div><div>DOM3规定几类事件</div><div>UI(User Interface, 用户界面）事件</div><div>焦点事件</div><div>鼠标事件</div><div>滚轮事件</div><div>文本事件</div><div>键盘事件</div><div>合成事件：当输入法编辑器输入字符时触发</div><div>变动事件：底层DOM结构发生变化时触发</div><div><br/></div><div><b>UI事件</b></div><div><b>load</b>: 页面完全加载后在window上触发，当图像加载完毕时在&lt;img&gt;元素上触发，当嵌入内容加载完毕时在&lt;object&gt;元素上触发</div><div>所有浏览器都在window上面实现了load事件，以确保向后兼容</div><div>如果在页面加载前操作document.body会导致错误</div><div>&lt;script&gt;元素也会触发load事件，只有设置src属性后，才会开始下载JavaScript文件，&lt;link&gt;元素相似</div><div><br/></div><div><b>unload</b>: 页面完全卸载后在window触发，所有框架卸载后在框架集触发，当嵌入内容卸载完毕后在&lt;object&gt;元素上触发</div><div>EventUtil.addHandler(window, 'unload', function(event){</div><div>     alert('Unloaded');</div><div>});</div><div><br/></div><div><b>abort</b>: 用户停止下载过程，嵌入内容未加载完，在&lt;object&gt;元素上触发</div><div><b>error</b>: JavaScript错误时在window上触发，无法加载图片在&lt;img&gt;元素上触发</div><div><b>select</b>: 用户选择一个或多个字符</div><div><b>resize</b>: 当窗口或框架的大小变化时在window或框架上触发</div><div><b>IE, Safari, Chrome和Opera会在浏览器窗口变化了1像素时触发resize事件，然后随着变化不断重复触发。Firefox则只会在用户停止调整窗口大小时才会触发resize事件。</b></div><div><b>所以不要在这个事件的处理程序中加入大计算量的代码，这些代码可能被频繁执行，从而导致浏览器反应明显变慢。</b></div><div>浏览器最小化或最大化时也会触发resize事件</div><div><br/></div><div><b>scroll: 滚动的对象触发</b></div><div>EventUtil.addHandler(window,'scroll',function(event){<br/>
     if(document.compatMode=='CSS1Compat'){<br/>
          alert(document.documentElement.scrollTop);<br/>
     }else{<br/>
          alert(document.body.scrollTop);<br/>
     }</div><div>});</div><div><br/></div><div><b>焦点事件</b></div><div><b>blur</b>：元素失去焦点时触发，这个事件不会冒泡</div><div>DOMFocusIn：与focus等价，但冒泡</div><div>DOMFocusOut: HTML事件的blur通用版本</div><div><b>focus</b>：元素获取焦点时触发，不会冒泡</div><div>focusin：与focus等价，但冒泡，firefox不支持</div><div>focusout: Firefox不支持</div><div>焦点从页面中的一个元素移动到另一个元素，触发顺序：</div><div>focusout A-&gt;focusin B -&gt; blur A -&gt; DOMFocusOut A -&gt; focus B -&gt; DOMFocusIn B</div><div><br/></div><div><b>鼠标与滚轮事件</b></div><div>click</div><div>dbclick</div><div>mousedown</div><div>mouseenter</div><div>mouseleave</div><div>mousemove</div><div>mouseout</div><div>mouseover</div><div>mouseup</div><div><br/></div><div><b>除了mouseenter和mouseleave，所有鼠标事件都会冒泡</b></div><div>只有在同一个元素上相继触发mousedown和mouseup事件，才会触发click</div><div><b>dbclick</b>: mousedown-&gt;mouseup-&gt;click-&gt;mousedown-&gt;mouseup-&gt;click-&gt;dbclick （IE8及之前版本会跳过第二个mousedown和click）</div><div><b>检测能力</b></div><div>var isSupperted=document.implementation.hasFeature('MouseEvents','2.0');</div><div>var isSupperted=document.implementation.hasFeature('MouseEvent','3.0');</div><div><br/></div><div><b>客户区坐标位置</b></div><div>这个位置信息保存在事件对象的<b>clientX和clientY</b>中</div><div><br/></div><div><b>页面坐标位置</b></div><div>页面坐标通过事件对象的<b>pageX和pageY</b>属性范围。</div><div><b>混杂模式：document.body 标准模式：document.documentElement</b></div><div><br/></div><div><b>屏幕坐标的位置</b></div><div><b>screenX和screenY</b></div><div><br/></div><div>DOM通过event对象的relatedTarget属性提供相关属性的信息，只有mouseover和mouseout事件才会包含值；IE中在mouseover事件触发时fromElement保存相关元素；而mouseout事件触发时toElement属性保存相关元素</div><div><br/></div><div><b>鼠标事件</b></div><div>DOM中鼠标的键有3个值：0表示主鼠标；1表示中间；2表示次鼠标键。而IE中有很大差距</div><div><br/></div><div><b>鼠标滚轮事件</b></div><div><b>mousewheel</b></div><div><b>wheelDelta</b>保存滑动的方向值；通常只需要知道鼠标滚动的方向就够了，而这通过检测wheelDelta的正负号来确定</div><div><br/></div><div><b>触摸设备</b></div><div>不支持dbclick；轻击可单击元素触发mousmove。</div><div>mousemove事件也会触发mouseover和mouseout事件</div><div><br/></div><div><b>键盘与文本事件</b></div><div>keydown</div><div>keypress</div><div>keyup</div><div><br/></div><div><b>HTML5事件</b></div><div>contextmenu</div><div>beforeunload</div><div>DOMContentLoaded</div><div><b>readystatechange</b></div><div>     <b>uninitialized 未初始化</b></div><div><b>     loading 正在加载</b></div><div><b>     loaded 加载完毕</b></div><div><b>     interactive 交互</b></div><div><b>     complete 完成</b></div><div>pageshow和pagehide</div><div>haschange</div><div><br/></div><div><b>设备事件</b></div><div>orientationchange</div><div>MozOrientation</div><div>deviceorientation</div><div>devicemotion</div><div><br/></div><div><b>触摸与手势事件</b></div><div>touchstart</div><div>touchmove</div><div>touchend</div><div>touchcancel</div><div><br/></div><div>内存和性能</div><div>事情委托</div><div>移除事件处理程序</div><div><br/></div><div><b>模拟事件</b></div><div><b>DOM: document.createEvent() -&gt; event.initMouseEvent -&gt; btn.dispatchEvent</b></div><div><b>IE: document.createEventObject() -&gt; btn.fireEvent()</b></div><div><br/></div><div><span style="font-size: 19px;"><span style="color: rgb(65, 173, 28);">Chapter 17 错误处理与调试</span></span></div><div><br/></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 19px;">Chaper 20 JSON</span></span></div><div>JSON(JavaScript Object Notation, JavaScript对象表示法)。JSON直接传给eval()，而且不必创建DOM对象</div><div>语法：</div><div>1. <b>简单值</b>：字符串，数值，布尔值和null。但JSON不支持特殊值undefined。</div><div>2. <b>对象</b>：表示一组无序键值对</div><div>3. <b>数组</b>：表示一组有序值得列表</div><div><br/></div><div>简单值</div><div><b>JavaScript字符串与JSON字符串的最大区别在于，JSON字符串必须使用双引号（单引号会导致语法错误）</b></div><div><br/></div><div>JSON对象</div><div>早期的JSON解析器基本上就是使用JavaScript的<b>eval()</b>函数，由于JSON是JavaScript语法的子集，因此eval()函数可以解析、解释并返回JavaScript对象和数组。</div><div>ECMAScript 5定义了全局变量JSON，支持有IE8+, Firefox3.5+, Safari4+, chrome, Opera 10.5+。</div><div>对于早期浏览器，可以引入json2.js文件。shim: <a href="https://github.com/douglascrockford/JSON-js">https://github.com/douglascrockford/JSON-js</a></div><div>JSON对象有两个方法：<b>stringify()</b>和<b>parse()</b></div><div>在序列化JavaScript对象时所有函数及原型成员都会被忽略。值为undefined的任何属性都会被跳过。</div><div>JSON.stringify()还可以接收另外两个参数：<b>1. 过滤器</b>，可以为一个数组，也可为一个函数；<b>2. 表示是否在JSON字符串中保留缩进</b>。最大的缩进空格数为10</div><div><b>为对象定义toJSON()方法</b>，返回其自身的JSON数据格式。调用JSON.stringify()函数序列化该对象的顺序如下：</div><div>1. 如果存在toJSON()方法而且能取得有效值，则调用该方法。否则，返回对象本身；</div><div>2. 如果提供第二个参数，应用这个函数过滤器；传入函数过滤器的值为第1步返回的值；</div><div>3. 对第2步返回的每个值进行相应的序列化；</div><div>4. 如果提供第三个参数，执行相应的格式化。</div><div><br/></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 19px;">Chapter 21 Ajax与Comet</span></span></div><div><b>Ajax Asynchronous JavaScript + XML</b></div><div>Ajax技术的核心是<b>XMLHttpRequest对象</b>（简称XHR）</div><div><b>创建一个兼容性的XHR</b></div><div>function <b>createXHR()</b>{<br/>
     if (typeof XMLHttpRequest !='undefined'){<br/>
          return new XMLHttpRequest();<br/>
     }<br/>
     else if(typeof arguments.callee.activeXString!='string'){<br/>
          var versions=['MSXML2.XMLHttp.6.0','MSXML2.XMLHttp.3.0','MSXML2.XMLHttp'],i,len;<br/>
          for i=0,len=versions.length;i&lt;len;i++){<br/>
               try{<br/>
                    new ActiveXObject(versions[i]);<br/>
                    arguments.callee.activeXString=versions[i];<br/>
               }catch(ex){<br/><br/>
               }<br/>
          }<br/>
          return new ActiveXObject(arguments.callee.activeXString);         <br/>
     }else{<br/>
          throw new Error('No XHR object available.');<br/>
     }</div><div>}</div><div>创建一个XHR对象</div><div>var xhr=createXHR();</div><div>调用<b>open()方法</b>，接受3个参数：<b>请求类型（‘GET', 'POST'等）</b>；<b>请求的URL</b>；<b>是否异步</b></div><div>xhr.open('get', 'example.php',false); //请求同步的信息</div><div><b>调用send()方法</b></div><div>在收到响应后，响应的数据会自动填充XHR对象的属性，相关属性如下：</div><div><b>responseText: 返回的文本</b></div><div><b>responseXML</b>: 响应类型，'text/html', 或'application/xml'等</div><div><b>status</b>: 响应的HTTP状态</div><div><b>statusText</b>: HTTP状态的说明</div><div><b>状态代码304</b>表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本</div><div><br/></div><div>检测XHR对象的<b>readyState属性</b>，来获取响应情况</div><div>0：未初始化，未调用open()方法</div><div>1：启动，已调用open()方法，但未调用send()方法</div><div>2：发送，已调用send()方法，但尚未收到响应</div><div>3：接收，已经接收到部分响应数据</div><div><b>4：完成，已经全部收到响应的数据</b></div><div><br/></div><div>调用onreadystatechange属性来检测XHR对象的readystate变化</div><div>var xhr=createXHR();<br/>
xhr.<b>onreadystatechange</b>=function(){<br/>
     if (<b>xhr.readyState==4</b>){<br/>
          if (<b>(xhr.status&gt;=200) &amp;&amp; (xhr.status&lt;300) || xhr.status==304</b>){<br/>
               alert(xhr.responseText);<br/>
          }else{<br/>
               alert('Request was unsuccessful:'+xhr.status);<br/>
          }<br/>
     }<br/>
};<br/>
xhr.<b>open</b>('get','example.txt',true);</div><div>xhr.<b>send</b>(null);</div><div><br/></div><div>在接收到响应前可以调用abort()方法来取消异步请求</div><div>xhr.<b>abort</b>()；</div><div><br/></div><div><b>HTTP的头部信息</b></div><div>默认情况下，在发送XHR请求的同时，还会发送下列头部信息</div><div><b>Accept</b>: 浏览器处理的类型</div><div><b>Accept-Charset</b>: 浏览器显示的字符集</div><div><b>Accept-Encoding</b>: 压缩编码</div><div><b>Accept-Language</b>: 浏览器当前语言</div><div><b>Connection</b>: 浏览器与服务器之间连接的类型</div><div><b>Cookie</b>: 当前页面设置的任何Cookie</div><div><b>Host</b>: 发出请求页面所在的域</div><div><b>Referer</b>: 发出请求的页面的URI</div><div><b>User-Agent</b>: 浏览器用户代理字符串</div><div><br/></div><div>使用<b>setRequestHeader()</b>方法自定义请求的头部信息</div><div><b>必须在调用open()方法后且在调用send()方法前调用setRequestHeader()</b></div><div>调用XHR对象的<b>getRequestHeader()</b>方法传入头部名称，获取响应头部信息；而调用<b>getAllResponseHeaders()</b>方法获取所有头部信息字符串</div><div>使用GET方法，尾端的查询字符串的键和值都须使用encodeURLComponent()进行编码</div><div>function <b>addURLParam(url,name,value)</b>{<br/>
     url+=(url.indexOf('?')==-1?'?':'&amp;');<br/>
     url+=encodeURIComponent(name)+'='+encodeURIComponent(value);<br/>
     return url;</div><div>};</div><div>使用XHR模仿表单提交，首先<b>将Content-Type头部信息设置为application/x-www-form-urlencoded</b>。如果不设置Content-Type头部信息，就不能再服务器的$_POST中取得数据，必须借助$HTTP_RAW_POST_DATA读取。</div><div><br/></div><div><b>XMLHttpRequest 2级</b></div><div>FormData类型，为序列化表单以及创建与表单格式相同的数据（通过XHR传输）提供便利</div><div>var data=new FormData();</div><div>data.append('name','mbl');</div><div>var data=new FormData(document.form[0]);</div><div><br/></div><div><br/></div><div>xhr.open('get','example.php',true);<br/>
var form=document.getElementById('user-info');</div><div><b>xhr.send(new FormData(form));</b></div><div><br/></div><div><b>IE8为XHR对象添加一个timeout属性，表示请求在等待响应多少毫秒后被终止</b>。在调用open()方法后，可设置：</div><div>xhr.timeout=1000;<br/>
xhr.<b>ontimeout</b>=function(){<br/>
     alert('Request did not return in a second.');</div><div>};</div><div>设定timeout后，如果在超时终止后访问status属性，会导致错误，为避免浏览器报告错误，可以将status语句封装在一个try-catch语句中</div><div>IE8+是唯一支持超时设定的浏览器</div><div><br/></div><div> <b>overrideMimeType</b>()方法重写服务器返回的MIME类型</div><div><br/></div><div><b>进度事件——草案标准</b></div><div>loadstart</div><div>progress</div><div>error</div><div>abort</div><div>load</div><div>loadend</div><div>每个请求都触发loadstart事件开始，接下来是一或多个progress事件，然后触发error、abort或load事件中一个，最后触发loadend事件结束</div><div><br/></div><div><b>跨域资源共享</b></div><div>XHR实现Ajax通信的限制：跨域安全策略。默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源</div><div><br/></div><div><b>CORS(Cross-Origin Resource Sharing, 跨域资源共享）</b>，W3C的一个工作草案</div><div>在发送请求时，需要附加一个origin头部，包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头信息是否给予响应</div><div>Origin: <a href="http://www.example.com/">http://www.example.com</a></div><div>如果服务器接受请求，则再Access-Control-Allow-Origin头部中回发相同的资源（公共资源可回发“*”）</div><div>Access-Control-Allow-Origin: <a href="http://www.example.com/">http://www.example.com</a></div><div><br/></div><div><b>IE CORS的实现</b></div><div>IE8中引入了<b>XDR(XDomainRequest)类型</b>，可实现安全可靠的跨域通信</div><div>XDR与XHR不同之处：</div><ul><li>cookie不会随请求发送，也不会随响应返回</li><li>只能设置请求头部信息中的Content-Type字段</li><li>不能访问响应头部信息</li><li>只支持GET和POST请求</li></ul><div><br/></div><div>Firefox 3.5+、Safari4+、Chrome、iOS版Safari和Android平台中的WebKit都通过XMLHttpRequest实现了CORS的原生支持，有以下限制：</div><div>不能使用setRequestHeader()设置自定义头部</div><div>不能发送和接收cookie</div><div>调用getAllResponseHeaders()方法总会返回空字符串</div><div><br/></div><div><b>跨浏览器的CORS</b></div><div>function <b>createCORSRequest(method,url)</b>{<br/>
     var xhr=new XMLHttpRequest();<br/>
     if (&quot;<b>withCredentials</b>&quot; in xhr){<br/>
          xhr.open(method,url,true);<br/>
     }else if(typeof XDomainRequest != 'undefined'){<br/>
          xhr=new XDomainRequest();<br/>
          xhr.open(method,url);<br/>
     }else{<br/>
          return null;<br/>
     }<br/>
     return xhr;</div><div>}</div><div><b>其他跨域技术</b></div><div><b>图像Ping</b></div><div>使用&lt;img/&gt;标签动态创建图像，是一种与服务器进行简单、单向的跨域通信的一种方式。只能通过侦听load和error事件，得到响应什么时候来到，浏览器拿不到任何具体的数据</div><div><b>JSONP （JSON with padding）</b></div><div>JSONP由两部分组成：回调函数和数据。JSONP是通过动态&lt;script&gt;元素，使用时可以为src属性指定一个跨域URL。</div><div>JSONP有两点不足：1. JSONP是从其他域中加载代码执行，如果其他域不安全，则会夹带一些恶意代码；2. 很难检测JSONP请求是否成功</div><div><br/></div><div><b>Comet</b></div><div>实现Comet的方式：<b>长轮询和流</b></div><div><b>短轮询</b>：定时向服务器发送信息； <b>长轮询：服务器返回响应，然后再向服务器发送下一个信息</b>。期间要建立多个HTTP连接</div><div><b>HTTP流</b>：在页面的整个生命周期只使用一个HTTP连接</div><div>所有服务器端语言都支持打印输出缓存然后刷新（将输出缓存中的内容一次性全部发送给客户端），这是实现HTTP流的关键</div><div><br/></div><div>Web Sockets</div><div><br/></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 19px;">Chapter 22 高级技巧</span></span></div><div>高级函数</div><div><b>作用域安全的构造函数</b></div><div>使用构造函数要调用new来生成实例，而直接调用，那么this会映射到全局对象window上，导致错误对象属性的意外增加。所以创建一个作用域安全构造函数</div><div>function Person(name,age,job){<br/>
     <b>if(this instanceof Person){</b><br/>
          this.name=name;<br/>
          this.age=age;<br/>
          this.job=job;<br/>
     <b>}else{</b><br/>
          <b>return new Person(name,age,job);</b><br/>
     <b>}</b></div><div>}</div><div><b>惰性载入函数</b></div><div>多数JavaScript代码包含大量的if语句，而调用时，要每次执行if语句进行判断。可以通过惰性载入的技巧来只执行一次if语句。</div><div><b>实现方式1：通过函数覆盖的形式</b></div><div>function createXHR(){<br/>
     if(typeof XMLHttpRequest != 'undefined'){<br/>
          createXHR=function(){<br/>
               return new XMLHttpRequest();<br/>
          };<br/>
     }else if(typeof ActiveXObject != 'undefined'){<br/>
          createXHR=function(){<br/>
               if(typeof arguments.callee.activeXString!='string'){<br/>
                    var versions=['MSXML2.XMLHttp.6.0','MSXML2.XMLHttp.3.0','MSXML2.XMLHttp'],i,len;<br/>
                    for(i=0,len=versions.length;i&lt;len;i++){<br/>
                         try{<br/>
                              new ActiveXObject(versions[i]);<br/>
                              arguments.callee.activeXString=versions[i];<br/>
                         }catch(ex){<br/><br/>
                         }<br/>
                    }<br/>
                    return new ActiveXObject(arguments.callee.activeXString);<br/>
               }<br/>
          };<br/>
     }else{<br/>
          createXHR=function(){<br/>
               throw new Error('No XHR object available');<br/>
          }<br/>
     }</div><div>}</div><div><b>实现方式2：通过声明函数时，指定适当函数的形式</b></div><div>var createXHR=(function(){<br/>
     if(typeof XMLHttpRequest != 'undefined'){<br/>
          return function(){<br/>
               return new XMLHttpRequest();<br/>
          };<br/>
     }else if(typeof ActiveXObject != 'undefined'){<br/>
          return function(){<br/>
               if(typeof arguments.callee.activeXString!='string'){<br/>
                    var versions=['MSXML2.XMLHttp.6.0','MSXML2.XMLHttp.3.0','MSXML2.XMLHttp'],i,len;<br/>
                    for(i=0,len=versions.length;i&lt;len;i++){<br/>
                         try{<br/>
                              new ActiveXObject(versions[i]);<br/>
                              arguments.callee.activeXString=versions[i];<br/>
                         }catch(ex){<br/><br/>
                         }<br/>
                    }<br/>
                    return new ActiveXObject(arguments.callee.activeXString);<br/>
               }<br/>
          };<br/>
     }else{<br/>
          return function(){<br/>
               throw new Error('No XHR object available');<br/>
          }<br/>
     }</div><div>})();</div><div><br/></div><div><b>函数绑定</b></div><div>将函数绑定到指定的执行环境，正确使用this来获得值或方法</div><div>function bind(fn, context){</div><div>     return function(){<br/>
          return fn.apply(context,arguments);<br/>
     }</div><div>}</div><div>ECMAScript5为所有函数定义一个原生的bind()方法，支持的浏览器：IE9+, Firefox4+和Chrome。</div><div>但被绑定的函数比普通函数相比有更多的开销，需要更多内存</div><div><br/></div><div><b>函数柯里化（function currying）</b></div><div>调用另一个函数并为它传入要柯里化的函数和必要参数</div><div>function carry(fn){<br/>
     var args=Array.prototype.slice.call(arguments,1);<br/>
     return function(){<br/>
          var innerArgs=Array.prototype.slice.call(arguments);<br/>
          var finalArgs=args.concat(innerArgs);<br/>
          return fn.apply(null,finalArgs);<br/>
     };</div><div>}</div><div><br/></div><div><b>防篡改对象</b></div><div><b>不可扩展对象</b>：Object.preventExtensions(); Object.isExtensible();</div><div><b>密封的对象</b>：不能删除属性和方法；Object.seal(); Object.isSealed();</div><div><b>冻结的对象</b>：既不可扩展，又是密封；Object.freeze(); Object.isFrozen();</div><div><br/></div><div><b>高级定时器</b></div><div>JavaScript是运行于单线程的环境中，定时器仅仅只是计划代码在未来某个时间执行</div><div>setTimeout(function(){<br/>
     //代码<br/>
     setTimeout(arguments.callee,interval);</div><div>},interval);</div><div><br/></div><div><b>Yielding Processess</b></div><div>运行在浏览器中的JavaScript被分配了一个确定数量的资源，JavaScript是被限制的。其中一个限制是长时间运行脚本的制约，如果代码运行超过特定时间或者特定语句数量就不让它继续执行。</div><div>长时间的运行循环，可以通过数组分块（array chunking），小块小块地处理数组。基本思想是为处理的项目创建一个队列，然后使用定时器取出下一个要处理的项目，再设置另一个定时器。</div><div><br/></div><div><b>函数节流</b></div><div>在IE中使用onresize事件会耗费大量资源。因为IE每次移动都会repaint和reflow页面。 而这是没有必要的。只要在用户resize停下或者相隔一定时间调用函数即可。</div><div>function throttle(method,context){<br/>
     clearTimeout(method.tId);<br/>
     method.tId=setTimeout(function(){<br/>
          method.call(context);<br/>
     },100);</div><div>}</div><div><br/></div><div>自定义事件 P616</div><div>拖放 P618</div><div>拖放的概念：创建一个绝对定位的元素，使其可以用鼠标移动</div><div>修缮拖放功能：用户在元素点击拖放时的位置，在拖放过程中，应固定一致</div><div><br/></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 19px;">Chapter 23 离线应用于客户端存储</span></span></div><div><b>离线检测</b></div><div>HTML5定义一个<b>navigator.onLine</b>属性，true表示设备能上网，false表示设备离线。但存在兼容性问题</div><div>HTML5还定义两个事件：online和offline</div><div><br/></div><div><b>应用缓存（application cache）</b></div><div>定义一个描述文件（manifest file）</div><div>&lt;html manifest=&quot;/offline.manifest&quot;&gt;</div><div>applicationCache对象，这个对象有一个status属性，检测缓存状态：0：无缓存；1：闲置；2：检查中；3：下载中；4：更新完成，通过swapCache()来使用；5：废弃</div><div>响应的事件：checking, error, noupdate, downloading, progress, updateready, cached</div><div>applicationCache.update()手工干预，更新缓存；正常的监听事件更新：</div><div>EventUtil.addHandler(applicationCache,'updateready',function(){<br/>
     applicationCache.swapCache();</div><div>});</div><div><br/></div><div><b>数据存储</b></div><div><b>Cookie</b></div><div>HTTP cookie, 最初是在客户端用于存储会话信息，该标准要求服务器对任何HTTP请求发送set Cookie HTTP头作为响应的一部分，其中包含会话信息。</div><div><b>cookie的构成：名称，值，域，路径，失效时间，安全标志</b></div><div>Cookie Util代码：P631</div><div>子cookie，在一个名称-值中，存储多个名称</div><div><br/></div><div><b>Web存储机制</b></div><div>Web Storage: <b>sessionStorage</b>，<b>globalStorage</b></div><div><b>localStorage</b>（一般浏览器5M，其他2.5M）</div><div>对Storage对象进行任何修改，都会在文档上触发storage事件</div><div><br/></div><div><b>IndexedDB</b></div><div>IndexedDB最大的特色是使用对象保存数据，而不是使用表来保存数据</div><div><br/></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 19px;">Chapter 24 最佳实践</span></span></div><div>可维护性</div><div>松散耦合</div><div>解耦HTML/JavaScript</div><div>解耦CSS/JavaScript</div><div>解耦应用逻辑/事件处理程序</div><div><br/></div><div>编程实践</div><div>1. 尊重对象所有权；2. 避免全局量；3. 避免与null进行比较；4. 使用常量。 将数据和使用它的逻辑进行分离</div><div><br/></div><div><b>性能</b></div><div>注意作用域</div><div>1. 避免全局查找；2. 避免with语句</div><div>选择正确方法</div><div>1. 避免不必要的属性查找（缓存多次使用的属性）；2. 优化循环 （Duff装置，？）；3. 避免双重解析，比如调用eval()，用函数对象创建函数，和在超时函数中使用字符串；都会在JavaScript代码运行的同时必须新启动一个解析器来解析新的代码</div><div>5. 性能的其他事项 原生方法比较快（C、C++类型实现的）；switch语句比较快；位运算符比较快</div><div>最小化语句</div><div>1. 多个变量声明用一个语句；2.使用数组和对象字面量</div><div>优化DOM交互</div><div>1. 最小化现场更新；2. 使用innerHTML；3. 使用事件代理（用父节点绑定函数）；4.注意HTMLCollection 先缓存对象</div><div><br/></div><div><b>HTTP压缩</b></div><div>对于Apache Web服务器，两个模块可以进行HTTP压缩：mod_gzip(Apache 1.3.x)和mod_deflate(Apache 2.0.x)</div><div>对于mod_gzip，可以给http.conf文件或者是.htaccess文件启动JavaScript自动压缩</div><div>mod_gzip_item_include file \.js%</div><div>对于mod_deflate</div><div>addOutputFilterByType DEFLATE application/x-javascript</div><div><br/></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 19px;">附录B 严格模式</span></span></div><div><b>选择使用</b></div><div>&quot;use strict&quot;; //进入全局模式</div><div>也可以只在函数中打开严格对象：</div><div>function doSomething(){</div><div>     &quot;use strict&quot;;</div><div>     //其他代码</div><div>}</div><div><br/></div><div><b>变量</b></div><div>1. 不允许创建全局变量；2. 不能对变量调用delete操作符</div><div><br/></div><div><b>对象</b></div><div>在使用对象字面量时，属性名必须唯一</div><div><br/></div><div><b>函数</b></div><div>1. 函数的参数必须唯一（而在非严格模式下重名参数会访问最后一个）；2. 淘汰arguments.callee和arguments.caller；3. 只能在脚本顶部和函数内部声明函数</div><div><br/></div><div><b>eval()</b></div><div>它在包含上下文中不再创建变量或函数</div><div><br/></div><div><b>eval和arguments</b></div><div>禁止使用eval和arguments作为标识符，也不允许读写它们的值</div><div><br/></div><div><b>抑制this</b></div><div>严格模式下，this的值为null</div><div><br/></div><div><b>抛弃with语句</b></div><div><br/></div><div><span style="color: rgb(65, 173, 28);">By Chunzhen 20160314</span></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 